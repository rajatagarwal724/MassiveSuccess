package companies.doordash.repeat;

import java.util.*;

/**
 * DoorDash Dasher Schedule Optimizer - Maximum Revenue Delivery Scheduling
 * 
 * Problem: Given a list of deliveries with start times, end times, and payments,
 * find the maximum amount of money a dasher can make by selecting non-overlapping
 * deliveries within their available time window.
 * 
 * This is a variant of the "Weighted Job Scheduling" problem.
 * 
 * Time Complexity: O(n log n) for sorting + O(n²) for DP = O(n²)
 * Space Complexity: O(n) for storing deliveries and DP array
 */
public class DasherScheduleOptimizer {
    
    static class Delivery {
        int start;
        int end;
        int pay;
        int index; // Original index for tracking
        
        public Delivery(int start, int end, int pay, int index) {
            this.start = start;
            this.end = end;
            this.pay = pay;
            this.index = index;
        }
        
        @Override
        public String toString() {
            return String.format("Delivery[%d: %d-%d, $%d]", index, start, end, pay);
        }
    }
    
    /**
     * Main method to find maximum revenue from delivery scheduling
     * @param startTime When dasher starts their shift
     * @param endTime When dasher ends their shift  
     * @param dStarts Start times of each delivery
     * @param dEnds End times of each delivery
     * @param dPays Payment for each delivery
     * @return Maximum revenue possible
     */
    public int maxRevenue(int startTime, int endTime, int[] dStarts, int[] dEnds, int[] dPays) {
        if (dStarts == null || dStarts.length == 0) return 0;
        
        // Create and filter valid deliveries
        List<Delivery> validDeliveries = new ArrayList<>();
        for (int i = 0; i < dStarts.length; i++) {
            // Delivery must start after shift starts and end before shift ends
            if (dStarts[i] >= startTime && dEnds[i] <= endTime) {
                validDeliveries.add(new Delivery(dStarts[i], dEnds[i], dPays[i], i));
            }
        }
        
        if (validDeliveries.isEmpty()) return 0;
        
        // Sort deliveries by end time for optimal processing
        validDeliveries.sort(Comparator.comparingInt(d -> d.end));
        
        return solveWeightedJobScheduling(validDeliveries);
    }


    public int maxRevenuePQ(int startTime, int endTime, int[] dStarts, int[] dEnds, int[] dPays) {
        if (dStarts == null || dStarts.length == 0) return 0;

        // Create and filter valid deliveries
        List<Delivery> validDeliveries = new ArrayList<>();
        for (int i = 0; i < dStarts.length; i++) {
            // Delivery must start after shift starts and end before shift ends
            if (dStarts[i] >= startTime && dEnds[i] <= endTime) {
                validDeliveries.add(new Delivery(dStarts[i], dEnds[i], dPays[i], i));
            }
        }

        if (validDeliveries.isEmpty()) return 0;

        // Sort deliveries by end time for optimal processing
        validDeliveries.sort(Comparator.comparingInt(d -> d.end));

        int maxProfit = 0;
        Queue<Delivery> minHeap = new PriorityQueue<>((d1, d2) -> d1.end - d2.end);

        for (int i = 0; i < validDeliveries.size(); i++) {
            var delivery = validDeliveries.get(i);
            int start = delivery.start;
            int end = delivery.end;
            int pay = delivery.pay;
            int index = delivery.index;

            while (!minHeap.isEmpty() && minHeap.peek().end <= start) {
                maxProfit = Math.max(maxProfit, minHeap.peek().pay);
                minHeap.poll();
            }

            minHeap.offer(new Delivery(start, end, pay + maxProfit, index));
        }

        while (!minHeap.isEmpty()) {
            maxProfit = Math.max(maxProfit, minHeap.peek().pay);
            minHeap.poll();
        }

        return maxProfit;
    }
    
    /**
     * Solve weighted job scheduling using dynamic programming
     */
    private int solveWeightedJobScheduling(List<Delivery> deliveries) {
        int n = deliveries.size();
        if (n == 0) return 0;
        if (n == 1) return deliveries.get(0).pay;
        
        // dp[i] = maximum revenue using deliveries 0..i
        int[] dp = new int[n];
        dp[0] = deliveries.get(0).pay;
        
        for (int i = 1; i < n; i++) {
            // Option 1: Don't take current delivery
            int withoutCurrent = dp[i - 1];
            
            // Option 2: Take current delivery
            int withCurrent = deliveries.get(i).pay;
            
            // Find the latest delivery that doesn't conflict with current
            int latestNonConflicting = findLatestNonConflicting(deliveries, i);
            if (latestNonConflicting != -1) {
                withCurrent += dp[latestNonConflicting];
            }
            
            dp[i] = Math.max(withoutCurrent, withCurrent);
        }
        
        return dp[n - 1];
    }
    
    /**
     * Find the latest delivery that doesn't conflict with delivery at index i
     */
    private int findLatestNonConflicting(List<Delivery> deliveries, int i) {
        for (int j = i - 1; j >= 0; j--) {
            // No conflict if previous delivery ends before or when current starts
            if (deliveries.get(j).end <= deliveries.get(i).start) {
                return j;
            }
        }
        return -1;
    }
    
    /**
     * Enhanced version that returns both maximum revenue and selected deliveries
     */
    public ScheduleResult getOptimalSchedule(int startTime, int endTime, 
                                           int[] dStarts, int[] dEnds, int[] dPays) {
        if (dStarts == null || dStarts.length == 0) {
            return new ScheduleResult(0, new ArrayList<>());
        }
        
        // Create and filter valid deliveries
        List<Delivery> validDeliveries = new ArrayList<>();
        for (int i = 0; i < dStarts.length; i++) {
            if (dStarts[i] >= startTime && dEnds[i] <= endTime) {
                validDeliveries.add(new Delivery(dStarts[i], dEnds[i], dPays[i], i));
            }
        }
        
        if (validDeliveries.isEmpty()) {
            return new ScheduleResult(0, new ArrayList<>());
        }
        
        validDeliveries.sort(Comparator.comparingInt(d -> d.end));
        
        // Solve and track selected deliveries
        int maxRevenue = solveWithTracking(validDeliveries);
        List<Delivery> selectedDeliveries = getSelectedDeliveries(validDeliveries);
        
        return new ScheduleResult(maxRevenue, selectedDeliveries);
    }
    
    private int solveWithTracking(List<Delivery> deliveries) {
        int n = deliveries.size();
        if (n == 0) return 0;
        
        int[] dp = new int[n];
        int[] parent = new int[n]; // To track which deliveries were selected
        Arrays.fill(parent, -1);
        
        dp[0] = deliveries.get(0).pay;
        
        for (int i = 1; i < n; i++) {
            int withoutCurrent = dp[i - 1];
            int withCurrent = deliveries.get(i).pay;
            
            int latestNonConflicting = findLatestNonConflicting(deliveries, i);
            if (latestNonConflicting != -1) {
                withCurrent += dp[latestNonConflicting];
            }
            
            if (withCurrent > withoutCurrent) {
                dp[i] = withCurrent;
                parent[i] = latestNonConflicting;
            } else {
                dp[i] = withoutCurrent;
                parent[i] = i - 1;
            }
        }
        
        return dp[n - 1];
    }
    
    private List<Delivery> getSelectedDeliveries(List<Delivery> deliveries) {
        // This is a simplified version - for full tracking, we'd need to modify the DP
        // For now, we'll use a greedy approach on the sorted deliveries
        List<Delivery> selected = new ArrayList<>();
        int lastEndTime = -1;
        
        for (Delivery delivery : deliveries) {
            if (delivery.start >= lastEndTime) {
                selected.add(delivery);
                lastEndTime = delivery.end;
            }
        }
        
        return selected;
    }
    
    /**
     * Optimized version using binary search for large datasets
     */
    public int maxRevenueOptimized(int startTime, int endTime, 
                                 int[] dStarts, int[] dEnds, int[] dPays) {
        List<Delivery> validDeliveries = new ArrayList<>();
        for (int i = 0; i < dStarts.length; i++) {
            if (dStarts[i] >= startTime && dEnds[i] <= endTime) {
                validDeliveries.add(new Delivery(dStarts[i], dEnds[i], dPays[i], i));
            }
        }
        
        if (validDeliveries.isEmpty()) return 0;
        
        validDeliveries.sort(Comparator.comparingInt(d -> d.end));
        
        return solveWithBinarySearch(validDeliveries);
    }
    
    /**
     * Use binary search to find latest non-conflicting job - O(n log n)
     */
    private int solveWithBinarySearch(List<Delivery> deliveries) {
        int n = deliveries.size();
        int[] dp = new int[n];
        dp[0] = deliveries.get(0).pay;
        
        for (int i = 1; i < n; i++) {
            int withoutCurrent = dp[i - 1];
            int withCurrent = deliveries.get(i).pay;
            
            // Binary search for latest non-conflicting delivery
            int latestNonConflicting = binarySearchLatestNonConflicting(deliveries, i);
            if (latestNonConflicting != -1) {
                withCurrent += dp[latestNonConflicting];
            }
            
            dp[i] = Math.max(withoutCurrent, withCurrent);
        }
        
        return dp[n - 1];
    }
    
    private int binarySearchLatestNonConflicting(List<Delivery> deliveries, int i) {
        int low = 0, high = i - 1, result = -1;
        
        while (low <= high) {
            int mid = (low + high) / 2;
            if (deliveries.get(mid).end <= deliveries.get(i).start) {
                result = mid;
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }
        
        return result;
    }
    
    /**
     * Result class for detailed schedule information
     */
    public static class ScheduleResult {
        public final int maxRevenue;
        public final List<Delivery> selectedDeliveries;
        
        public ScheduleResult(int maxRevenue, List<Delivery> selectedDeliveries) {
            this.maxRevenue = maxRevenue;
            this.selectedDeliveries = selectedDeliveries;
        }
        
        @Override
        public String toString() {
            return String.format("Max Revenue: $%d, Deliveries: %d", 
                               maxRevenue, selectedDeliveries.size());
        }
    }
    
    public static void main(String[] args) {
        DasherScheduleOptimizer optimizer = new DasherScheduleOptimizer();
        
        // Test case from problem
        System.out.println("=== DOORDASH DASHER SCHEDULE OPTIMIZER ===");
        
        int startTime = 0;
        int endTime = 10;
        int[] dStarts = {2, 3, 5, 7};
        int[] dEnds = {6, 5, 10, 11};
        int[] dPays = {5, 2, 4, 1};
        
        System.out.println("Input:");
        System.out.println("Shift time: " + startTime + " to " + endTime);
        System.out.println("Deliveries:");
        for (int i = 0; i < dStarts.length; i++) {
            System.out.println(String.format("  %d: [%d, %d] pays $%d", 
                             i, dStarts[i], dEnds[i], dPays[i]));
        }
        
        int maxRevenue = optimizer.maxRevenue(startTime, endTime, dStarts, dEnds, dPays);
        System.out.println("\nMax Revenue (Basic): $" + maxRevenue);

        int maxRevenue_PQ = optimizer.maxRevenuePQ(startTime, endTime, dStarts, dEnds, dPays);
        System.out.println("\nMax Revenue (Basic): $" + maxRevenue_PQ);
        
        // Test detailed schedule
//        ScheduleResult result = optimizer.getOptimalSchedule(startTime, endTime, dStarts, dEnds, dPays);
//        System.out.println("Detailed Result: " + result);
//        System.out.println("Selected deliveries:");
//        for (Delivery d : result.selectedDeliveries) {
//            System.out.println("  " + d);
//        }
//
//        // Test optimized version
//        int optimizedRevenue = optimizer.maxRevenueOptimized(startTime, endTime, dStarts, dEnds, dPays);
//        System.out.println("\nMax Revenue (Optimized): $" + optimizedRevenue);
//        System.out.println("Results match: " + (maxRevenue == optimizedRevenue));
//
//        // Additional test cases
//        testAdditionalCases(optimizer);
    }
    
    private static void testAdditionalCases(DasherScheduleOptimizer optimizer) {
        System.out.println("\n=== ADDITIONAL TEST CASES ===");
        
        // Test case 2: No valid deliveries
        System.out.println("\nTest 2: No valid deliveries");
        int result2 = optimizer.maxRevenue(0, 5, new int[]{6, 7}, new int[]{8, 9}, new int[]{10, 15});
        System.out.println("Expected: 0, Got: " + result2);
        
        // Test case 3: All deliveries conflict
        System.out.println("\nTest 3: All deliveries conflict");
        int result3 = optimizer.maxRevenue(0, 10, new int[]{1, 2, 3}, new int[]{5, 6, 7}, new int[]{10, 20, 15});
        System.out.println("Expected: 20, Got: " + result3);
        
        // Test case 4: Non-overlapping deliveries
        System.out.println("\nTest 4: Non-overlapping deliveries");
        int result4 = optimizer.maxRevenue(0, 10, new int[]{1, 3, 6}, new int[]{2, 5, 8}, new int[]{5, 7, 3});
        System.out.println("Expected: 15, Got: " + result4);
    }
}
