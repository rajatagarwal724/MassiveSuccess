# Friends and Followers System Design for Social Media Platforms

## 1. Introduction

Storing and retrieving friend/follower relationships is a fundamental component of social media platforms. 
These relationships form the social graph that powers news feeds, 
recommendations, privacy controls, and many other features. The design must efficiently handle:

- High read-to-write ratio (many more relationship lookups than creations)
- Bidirectional relationships (friends) and unidirectional relationships (followers)
- Scale to billions of users and trillions of connections
- The "celebrity problem" where a small subset of users have millions of connections

This document details a Principal Engineer level approach to this problem, 
considering data models, storage solutions, caching strategies, and specialized optimizations.

## 2. Data Model Design

### 2.1 Conceptual Models

**Friendship Model (Bidirectional)**
A mutual connection between two users where both have agreed to be friends.

```
Friendship: (user_id_1, user_id_2, status, created_at)
```

**Follow Model (Unidirectional)**
A one-way connection where one user follows another.

```
Follow: (follower_id, followee_id, created_at)
```

### 2.2 Relational Schema

**Friends Table** (for bidirectional relationships)
```sql
CREATE TABLE friendships (
    friendship_id BIGINT PRIMARY KEY,
    user_id_1 BIGINT NOT NULL,
    user_id_2 BIGINT NOT NULL,
    status VARCHAR(20) NOT NULL, -- PENDING, ACCEPTED, DECLINED, BLOCKED
    created_at TIMESTAMP NOT NULL,
    updated_at TIMESTAMP NOT NULL,
    CONSTRAINT unique_friendship UNIQUE(user_id_1, user_id_2),
    CONSTRAINT user_order CHECK (user_id_1 < user_id_2) -- Enforce canonical representation
);

-- Indexes
CREATE INDEX idx_friendships_user1 ON friendships(user_id_1);
CREATE INDEX idx_friendships_user2 ON friendships(user_id_2);
```

**Follows Table** (for unidirectional relationships)
```sql
CREATE TABLE follows (
    follow_id BIGINT PRIMARY KEY,
    follower_id BIGINT NOT NULL,
    followee_id BIGINT NOT NULL,
    created_at TIMESTAMP NOT NULL,
    CONSTRAINT unique_follow UNIQUE(follower_id, followee_id)
);

-- Indexes
CREATE INDEX idx_follows_follower ON follows(follower_id);
CREATE INDEX idx_follows_followee ON follows(followee_id);
```

### 2.3 Graph Database Model

For high-scale social networks, a graph database might be a more natural fit:

```cypher
// Neo4j Cypher examples

// Create users
CREATE (u1:User {id: 1, name: 'Alice'})
CREATE (u2:User {id: 2, name: 'Bob'})

// Create friendship (bidirectional)
MATCH (a:User {id: 1}), (b:User {id: 2})
CREATE (a)-[:FRIENDS_WITH {since: timestamp()}]->(b)
CREATE (b)-[:FRIENDS_WITH {since: timestamp()}]->(a)

// Create follow relationship (unidirectional)
MATCH (a:User {id: 1}), (b:User {id: 3})
CREATE (a)-[:FOLLOWS {since: timestamp()}]->(b)
```

## 3. Storage Strategies

### 3.1 Base Storage Layer

The optimal storage solution depends on scale and access patterns:

#### Small to Medium Scale (Millions of Users)
- **Relational Database (PostgreSQL/MySQL)** with proper sharding
- Friendship data can be stored in a canonical form (always storing the smaller user_id first) 
to avoid duplicates

#### Large Scale (Billions of Users)
- **Graph Databases** (Neo4j, Amazon Neptune, TigerGraph)
  - Natural representation of social connections
  - Efficient traversal for friend-of-friend queries
  - Built-in support for relationship properties
  
- **Custom Social Graph Solutions**
  - Facebook's TAO (The Association Object)
  - Twitter's FlockDB (specialized graph database)
  
### 3.2 Sharding Approach

Social graphs require effective sharding to scale horizontally:

**User-Based Sharding**
```
Shard key: user_id % NUM_SHARDS
```

Challenges:
- Queries spanning multiple users require cross-shard operations
- Celebrity nodes create hot shards

**Edge-Based Sharding**
```
Shard key: hash(follower_id + followee_id) % NUM_SHARDS
```

Challenges:
- Retrieving all followers/following for a user requires querying all shards
- Better distribution but higher query complexity

**Hybrid Sharding**
- Normal users: User-based sharding
- Celebrity users: Dedicated shards or special handling

## 4. The Celebrity Problem

The "celebrity problem" occurs when a small number of users have millions or even hundreds of millions of 
connections, creating hotspots and scalability challenges.

### 4.1 Detection and Classification

Define criteria to identify celebrity accounts:

```sql
SELECT followee_id, COUNT(*) as follower_count
FROM follows
GROUP BY followee_id
HAVING COUNT(*) > 100000
ORDER BY follower_count DESC;
```

### 4.2 Special Storage for Celebrity Users

**Approach 1: Separate Storage**
- Store celebrity relationships in a separate dedicated cluster
- Use different schema optimized for high fan-out

```sql
CREATE TABLE celebrity_followers (
    celebrity_id BIGINT NOT NULL,
    follower_id BIGINT NOT NULL,
    created_at TIMESTAMP NOT NULL,
    PRIMARY KEY (celebrity_id, follower_id)
) PARTITION BY HASH(follower_id);
```

**Approach 2: Denormalization**
- For each celebrity, store follower IDs in chunks/pages
- Each page contains a fixed number of followers (e.g., 10,000)

```sql
CREATE TABLE celebrity_follower_pages (
    celebrity_id BIGINT NOT NULL,
    page_id INT NOT NULL,
    follower_ids BIGINT[] NOT NULL, -- Array of follower IDs
    page_created_at TIMESTAMP NOT NULL,
    last_updated_at TIMESTAMP NOT NULL,
    PRIMARY KEY (celebrity_id, page_id)
);
```

**Approach 3: Two-Way Indexing with Limits**
- Store complete follower list for regular users
- For celebrities, store only a count and recent followers
- Store celebrities that a user follows in the user's record

### 4.3 Read-Time Optimizations

**Pagination and Cursor-Based Access**
- Never return full follower lists for celebrities
- Use cursor-based pagination to efficiently retrieve portions

```
GET /users/{celebrity_id}/followers?limit=100&cursor=last_seen_follower_id
```

**Materialized Follower Counts**
- Pre-compute and cache follower counts
- Update asynchronously

```sql
CREATE TABLE user_stats (
    user_id BIGINT PRIMARY KEY,
    follower_count BIGINT NOT NULL DEFAULT 0,
    following_count BIGINT NOT NULL DEFAULT 0,
    last_updated_at TIMESTAMP NOT NULL
);
```

## 5. Caching Strategy

### 5.1 Multi-Level Caching

**Application-Level Cache**
- In-memory caches (Redis/Memcached)
- Cache frequently accessed relationships

```
// Cache keys
followers:{user_id}:count           // Follower count
followers:{user_id}:page:{page_id}  // Page of followers
friends:{user_id}:ids              // Friend IDs for a user
```

**CDN Caching**
- For celebrity profiles, cache follower counts and top followers
- Use time-to-live (TTL) based on update frequency

**Edge Caching**
- Cache common queries at the edge nodes
- Regional caching for location-based social networks

### 5.2 Cache Invalidation

Managing cache consistency is crucial:

**Write-Through Caching**
- Update cache and database in the same transaction
- Ensures consistency but adds latency

**Write-Behind Caching**
- Update cache immediately, database asynchronously
- Better performance but risk of inconsistency

**Event-Based Invalidation**
- Publish relationship changes to a message queue
- Subscribers invalidate or update relevant caches

```
// Example with Redis and Kafka

1. User A follows Celebrity C
2. Update database
3. Publish event to Kafka: "follow_created:{follower_id=A,followee_id=C}"
4. Cache services consume event
5. Invalidate or update: followers:C:count, following:A:ids
```

## 6. Query Patterns and Optimizations

### 6.1 Common Queries

**Get User's Friends/Following**
```sql
-- Friends query
SELECT user_id_2 AS friend_id FROM friendships 
WHERE user_id_1 = ? AND status = 'ACCEPTED'
UNION ALL
SELECT user_id_1 AS friend_id FROM friendships 
WHERE user_id_2 = ? AND status = 'ACCEPTED';

-- Following query
SELECT followee_id FROM follows WHERE follower_id = ?;
```

**Get User's Followers**
```sql
SELECT follower_id FROM follows WHERE followee_id = ? LIMIT ? OFFSET ?;
```

**Check if User A Follows User B**
```sql
SELECT 1 FROM follows WHERE follower_id = ? AND followee_id = ?;
```

**Mutual Friends Query**
```sql
-- Get mutual friends (friend-of-friend intersection)
SELECT f1.friend_id 
FROM 
  (SELECT user_id_2 AS friend_id FROM friendships WHERE user_id_1 = ? AND status = 'ACCEPTED'
   UNION ALL
   SELECT user_id_1 AS friend_id FROM friendships WHERE user_id_2 = ? AND status = 'ACCEPTED') f1
JOIN
  (SELECT user_id_2 AS friend_id FROM friendships WHERE user_id_1 = ? AND status = 'ACCEPTED'
   UNION ALL
   SELECT user_id_1 AS friend_id FROM friendships WHERE user_id_2 = ? AND status = 'ACCEPTED') f2
ON f1.friend_id = f2.friend_id;
```

### 6.2 Performance Optimizations

**Precomputing Friend Lists**
- Materialize friend lists in a denormalized format
- Update asynchronously via event processing

```sql
CREATE TABLE user_friend_lists (
    user_id BIGINT PRIMARY KEY,
    friend_ids BIGINT[] NOT NULL,
    last_updated_at TIMESTAMP NOT NULL
);
```

**Bidirectional vs Two Unidirectional**
- For friends (bidirectional), store relationship once with canonical order
- For efficient querying, create two directed edges in the graph model

**Friend-of-Friend Optimizations**
- Pre-compute second-degree connections for recommendation features
- Use graph algorithms for efficient traversal

## 7. Read vs Write Optimization

Social graphs are read-heavy with occasional writes:

**Write Optimization Trade-offs**
- Batch processing for follows/unfollows
- Asynchronous counter updates
- Write-optimized storage (LSM trees)

**Read Optimization Trade-offs**
- Denormalization of relationships
- Heavy caching of popular nodes
- Fan-out-on-write for feed generation

### 7.1 Fan-out Approaches

**Fan-out-on-write**
- When a celebrity posts content, immediately distribute to follower feeds
- Works well for users with moderate follower counts
- Costly for celebrities with millions of followers

**Fan-out-on-read**
- When a user requests their feed, pull content from all followed accounts
- Inefficient for users following many accounts
- Better for celebrity followers

**Hybrid Approach**
- Fan-out-on-write for regular users
- Fan-out-on-read for celebrity content
- Requires identifying celebrity accounts and routing appropriately

## 8. Data Consistency and Integrity

### 8.1 Transaction Handling

**Friendship Request Flow**
```
1. User A sends friend request to User B
2. Begin transaction
3. Check if friendship already exists
4. Insert new friendship record with status='PENDING'
5. Commit transaction
```

**Follow/Unfollow Flow**
```
1. User A follows User B
2. Begin transaction
3. Insert follow record
4. Increment follower count for User B
5. Increment following count for User A
6. Commit transaction
```

### 8.2 Handling Failures

Resilience strategies for relationship management:

**Idempotent Operations**
- Design APIs to be safely retried
- Use natural keys or request IDs to detect duplicates

**Eventual Consistency**
- Accept that follower counts may be temporarily inconsistent
- Schedule periodic reconciliation jobs

**Conflict Resolution**
- Handle race conditions (e.g., simultaneous follow/unfollow)
- Use timestamp-based resolution or last-writer-wins

## 9. Scalability Benchmarks

System should be designed to handle:

- 1+ billion active users
- Average user: 300 friends/follows
- Celebrity users: 1M-100M followers
- 10,000+ follow/unfollow operations per second
- 1,000,000+ relationship queries per second

### 9.1 Storage Requirements

**Follows Table**
Assumptions:
- 1 billion users with avg. 300 follows each = 300 billion records
- Each record: ~24 bytes (8B follower_id + 8B followee_id + 8B timestamp)
- Total raw storage: ~7.2 TB
- With indexes, overhead: ~15 TB

**Celebrity Storage**
Assumptions:
- 100,000 celebrity users with avg. 1M followers each
- Special handling storage: ~2.4 TB

## 10. Implementation Considerations

### 10.1 Technology Stack Options

**Traditional Relational Approach**
- PostgreSQL/MySQL with appropriate sharding
- Redis for caching
- Kafka for event processing

**Graph Database Approach**
- Neo4j/Amazon Neptune/TigerGraph
- Specialized graph query language
- Native support for relationship traversal

**Custom Solution**
- TAO-like architecture (Facebook)
- Custom leader-follower caching scheme
- Dedicated follower/following services

### 10.2 Monitoring and Metrics

**Key Performance Indicators**
- p95/p99 latency for relationship queries
- Follow/unfollow success rate
- Cache hit ratio
- Follower count consistency

**Celebrity-Specific Metrics**
- Celebrity node query performance
- Celebrity follow operation latency
- Fan-out success rates for celebrity content

## 11. Conclusion

Storing and retrieving friend/follower relationships at scale requires a sophisticated approach that addresses:

1. Appropriate data modeling for different relationship types
2. Special handling for celebrity users
3. Effective sharding and partitioning strategies
4. Multi-level caching with proper invalidation
5. Query optimization for common social graph operations

By combining these techniques, a social media platform can efficiently manage billions of social connections while maintaining performance and consistency.