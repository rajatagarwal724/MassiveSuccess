# Top K Heavy Hitters - Kappa Architecture: Query Service

**Version:** 1.0
**Last Updated:** 2025-06-01

## 1. Query Service Overview

The Query Service provides access to the Top K Heavy Hitters results generated by the stream processing pipeline. It offers a RESTful API with flexibility in query parameters, caching, and authentication/authorization features.

### 1.1. Technologies

- **Primary Framework:** Spring Boot
- **Alternative Options:** Dropwizard, Quarkus, Micronaut
- **Caching:** Redis
- **Authentication:** OAuth 2.0 / JWT
- **API Documentation:** OpenAPI 3.0 (Swagger)

## 2. API Design

### 2.1. Core Endpoints

#### Get Top K Items

```
GET /api/v1/topk
```

Parameters:
- `window` (optional): Window type ("1m", "1h", "1d", "all"). Default: "1h"
- `k` (optional): Number of top items to return. Default: 10, Max: 1000
- `dimension` (optional): Filter by dimension. Default: "all"
- `dimensionValue` (optional): Filter by dimension value
- `itemType` (optional): Filter by item type. Default: "all"
- `startTime` (optional): Start time (ISO-8601)
- `endTime` (optional): End time (ISO-8601)

Response:
```json
{
  "metadata": {
    "window": "1h",
    "k": 10,
    "dimension": "all",
    "itemType": "all",
    "startTime": "2025-06-01T10:00:00Z",
    "endTime": "2025-06-01T11:00:00Z",
    "totalItems": 10,
    "approximationUsed": true,
    "maxErrorRate": 0.01
  },
  "items": [
    {
      "itemId": "product-123",
      "itemType": "product",
      "count": 15784,
      "errorBound": 158,
      "metadata": {
        "category": "electronics",
        "lastUpdated": "2025-06-01T11:15:30Z"
      }
    },
    // Additional items...
  ]
}
```

#### Get Item History

```
GET /api/v1/items/{itemId}/history
```

Parameters:
- `window` (optional): Window size ("1m", "1h", "1d"). Default: "1h"
- `startTime` (required): Start time (ISO-8601)
- `endTime` (required): End time (ISO-8601)

Response:
```json
{
  "metadata": {
    "itemId": "product-123",
    "window": "1h",
    "startTime": "2025-06-01T00:00:00Z",
    "endTime": "2025-06-01T12:00:00Z",
    "pointCount": 12
  },
  "points": [
    {
      "timestamp": "2025-06-01T00:00:00Z",
      "count": 5432,
      "rank": 3
    },
    // Additional time points...
  ]
}
```

#### Get Dimensions

```
GET /api/v1/dimensions
```

Response:
```json
{
  "dimensions": ["deviceType", "region", "userType", "pageCategory"],
  "dimensionValues": {
    "deviceType": ["mobile", "desktop", "tablet"],
    "region": ["na", "eu", "apac", "latam"],
    "userType": ["anonymous", "registered", "premium"],
    "pageCategory": ["home", "product", "category", "checkout"]
  }
}
```

### 2.2. Comparison Endpoints

```
GET /api/v1/topk/compare
```

Parameters:
- `baseWindow` (required): Base time window
- `compareWindow` (required): Comparison time window
- Other filtering parameters as in `/topk` endpoint

Response:
```json
{
  "metadata": {
    "baseWindow": "2025-05-25T00:00:00Z/2025-05-31T23:59:59Z",
    "compareWindow": "2025-06-01T00:00:00Z/2025-06-01T11:00:00Z",
    "k": 10,
    "dimension": "all"
  },
  "items": [
    {
      "itemId": "product-123",
      "baseCount": 57893,
      "compareCount": 15784,
      "percentChange": 9.8,
      "rankChange": 2
    },
    // Additional items...
  ]
}
```

## 3. Implementation

### 3.1. Service Layer

```java
@Service
public class HeavyHittersService {
    private final RedisTemplate<String, String> redisTemplate;
    private final CassandraTemplate cassandraTemplate;
    private final HeavyHittersCache cache;
    
    @Autowired
    public HeavyHittersService(
            RedisTemplate<String, String> redisTemplate,
            CassandraTemplate cassandraTemplate,
            HeavyHittersCache cache) {
        this.redisTemplate = redisTemplate;
        this.cassandraTemplate = cassandraTemplate;
        this.cache = cache;
    }
    
    public TopKResult getTopK(TopKQuery query) {
        // Check cache first
        String cacheKey = buildCacheKey(query);
        TopKResult cachedResult = cache.get(cacheKey);
        if (cachedResult != null) {
            return cachedResult;
        }
        
        // Determine data source based on query parameters
        TopKResult result;
        if (isRecent(query)) {
            result = getTopKFromRedis(query);
        } else {
            result = getTopKFromCassandra(query);
        }
        
        // Cache the result
        cache.put(cacheKey, result, getCacheTtl(query));
        
        return result;
    }
    
    private TopKResult getTopKFromRedis(TopKQuery query) {
        String redisKey = buildRedisKey(query);
        
        // Get top K items
        Set<ZSetOperations.TypedTuple<String>> topItems = 
            redisTemplate.opsForZSet().reverseRangeWithScores(redisKey, 0, query.getK() - 1);
        
        if (topItems == null || topItems.isEmpty()) {
            return TopKResult.empty(query);
        }
        
        // Get metadata
        String metaKey = redisKey.replace("topk:", "meta:");
        Map<Object, Object> meta = redisTemplate.opsForHash().entries(metaKey);
        
        // Transform results
        List<ItemFrequency> items = new ArrayList<>();
        for (ZSetOperations.TypedTuple<String> tuple : topItems) {
            String itemId = tuple.getValue();
            double count = tuple.getScore();
            
            // Get item metadata
            String itemKey = String.format("item:%s:%s", itemId, query.getDimension());
            Map<Object, Object> itemMeta = redisTemplate.opsForHash().entries(itemKey);
            
            items.add(new ItemFrequency(
                itemId,
                (long)count,
                itemMeta.containsKey("errorBound") ? 
                    Long.parseLong((String)itemMeta.get("errorBound")) : 0,
                itemMeta));
        }
        
        return new TopKResult(query, items, meta);
    }
    
    private TopKResult getTopKFromCassandra(TopKQuery query) {
        // Construct CQL query
        Select select = QueryBuilder.select()
            .from("heavy_hitters")
            .where(QueryBuilder.eq("window_type", query.getWindow()))
            .and(QueryBuilder.eq("dimension", query.getDimension()));
        
        if (query.getDimensionValue() != null) {
            select = select.and(QueryBuilder.eq("dimension_value", query.getDimensionValue()));
        }
        
        if (query.getItemType() != null) {
            select = select.and(QueryBuilder.eq("item_type", query.getItemType()));
        }
        
        select = select.and(QueryBuilder.gte("window_start", query.getStartTime()));
        select = select.and(QueryBuilder.lte("window_end", query.getEndTime()));
        
        // Execute query
        List<HeavyHitterRecord> records = cassandraTemplate.select(select, HeavyHitterRecord.class);
        
        // Transform and aggregate results
        Map<String, Long> itemCounts = new HashMap<>();
        for (HeavyHitterRecord record : records) {
            String itemId = record.getItemId();
            itemCounts.put(itemId, itemCounts.getOrDefault(itemId, 0L) + record.getCount());
        }
        
        // Sort and limit
        List<ItemFrequency> items = itemCounts.entrySet().stream()
            .sorted(Map.Entry.<String, Long>comparingByValue().reversed())
            .limit(query.getK())
            .map(entry -> new ItemFrequency(entry.getKey(), entry.getValue(), 0, Map.of()))
            .collect(Collectors.toList());
        
        return new TopKResult(query, items, Map.of());
    }
    
    // Helper methods for caching, key generation, etc.
    // ...
}
```

### 3.2. Controller Implementation

```java
@RestController
@RequestMapping("/api/v1")
@Tag(name = "Top K Heavy Hitters", description = "APIs for accessing top K frequent items")
public class HeavyHittersController {
    
    private final HeavyHittersService heavyHittersService;
    
    @Autowired
    public HeavyHittersController(HeavyHittersService heavyHittersService) {
        this.heavyHittersService = heavyHittersService;
    }
    
    @GetMapping("/topk")
    @Operation(summary = "Get top K items", description = "Returns the most frequent items based on query parameters")
    public ResponseEntity<TopKResponse> getTopK(
            @Parameter(description = "Window type") 
            @RequestParam(defaultValue = "1h") String window,
            
            @Parameter(description = "Number of items to return") 
            @RequestParam(defaultValue = "10") int k,
            
            @Parameter(description = "Dimension to filter by") 
            @RequestParam(defaultValue = "all") String dimension,
            
            @Parameter(description = "Dimension value") 
            @RequestParam(required = false) String dimensionValue,
            
            @Parameter(description = "Item type") 
            @RequestParam(defaultValue = "all") String itemType,
            
            @Parameter(description = "Start time (ISO-8601)") 
            @RequestParam(required = false) 
            @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) Instant startTime,
            
            @Parameter(description = "End time (ISO-8601)") 
            @RequestParam(required = false) 
            @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) Instant endTime) {
        
        // Validate input parameters
        if (k <= 0 || k > 1000) {
            return ResponseEntity.badRequest().body(
                new TopKResponse("Invalid k value. Must be between 1 and 1000", null));
        }
        
        // Set default time range if not specified
        if (startTime == null || endTime == null) {
            endTime = Instant.now();
            startTime = getDefaultStartTime(window, endTime);
        }
        
        // Build query
        TopKQuery query = new TopKQuery.Builder()
            .window(normalizeWindow(window))
            .k(k)
            .dimension(dimension)
            .dimensionValue(dimensionValue)
            .itemType(itemType)
            .startTime(startTime)
            .endTime(endTime)
            .build();
        
        // Get results
        TopKResult result = heavyHittersService.getTopK(query);
        
        // Transform to response
        TopKResponse response = transformToResponse(result);
        
        return ResponseEntity.ok(response);
    }
    
    // Additional endpoints
    @GetMapping("/items/{itemId}/history")
    public ResponseEntity<ItemHistoryResponse> getItemHistory(
            @PathVariable String itemId,
            @RequestParam(defaultValue = "1h") String window,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) Instant startTime,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) Instant endTime) {
        
        // Implementation...
        return ResponseEntity.ok(itemHistoryService.getHistory(itemId, window, startTime, endTime));
    }
    
    // Helper methods...
}
```

### 3.3. Caching Implementation

```java
@Component
public class HeavyHittersCache {
    
    private final Cache<String, TopKResult> cache;
    
    public HeavyHittersCache(@Value("${cache.max-size:1000}") int maxSize) {
        this.cache = CacheBuilder.newBuilder()
            .maximumSize(maxSize)
            .recordStats()
            .build();
    }
    
    public TopKResult get(String key) {
        return cache.getIfPresent(key);
    }
    
    public void put(String key, TopKResult value, Duration ttl) {
        cache.put(key, value);
    }
    
    public CacheStats getStats() {
        return cache.stats();
    }
}
```

## 4. Query Optimization Strategies

### 4.1. Caching Hierarchy

- **L1 Cache:** In-memory cache for frequently accessed results
- **L2 Cache:** Redis for distributed caching across service instances
- **Cache Invalidation:** Time-based expiration and explicit invalidation on updates

### 4.2. Pagination and Result Limiting

```java
@GetMapping("/topk")
public ResponseEntity<PagedTopKResponse> getTopKPaginated(
        // Other parameters...
        @RequestParam(defaultValue = "0") int page,
        @RequestParam(defaultValue = "20") int pageSize) {
    
    // Validate pagination parameters
    if (pageSize > 100) {
        pageSize = 100; // Cap maximum page size
    }
    
    // Calculate offset
    int offset = page * pageSize;
    
    // Get results with pagination
    TopKResult result = heavyHittersService.getTopK(query, offset, pageSize);
    
    // Transform to paginated response
    PagedTopKResponse response = transformToPaginatedResponse(result, page, pageSize);
    
    return ResponseEntity.ok(response);
}
```

### 4.3. Query Federation

For queries spanning multiple time windows or dimensions:

```java
public TopKResult getFederatedTopK(List<TopKQuery> queries) {
    // Execute queries in parallel
    CompletableFuture<TopKResult>[] futures = queries.stream()
        .map(query -> CompletableFuture.supplyAsync(
            () -> getTopK(query),
            queryExecutor))
        .toArray(CompletableFuture[]::new);
    
    // Wait for all results
    CompletableFuture.allOf(futures).join();
    
    // Combine results
    List<TopKResult> results = Arrays.stream(futures)
        .map(CompletableFuture::join)
        .collect(Collectors.toList());
    
    return mergeTopKResults(results);
}
```

## 5. Security Considerations

### 5.1. Authentication and Authorization

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .csrf().disable()
            .authorizeRequests()
            .antMatchers("/api/v1/health", "/api/v1/metrics").permitAll()
            .antMatchers("/api/v1/**").authenticated()
            .and()
            .oauth2ResourceServer()
            .jwt();
    }
    
    @Bean
    public JwtDecoder jwtDecoder() {
        return JwtDecoders.fromOidcIssuerLocation("https://auth.example.com");
    }
}
```

### 5.2. Role-Based Access Control

```java
@PreAuthorize("hasRole('ADMIN') or hasRole('ANALYST')")
@GetMapping("/topk/advanced")
public ResponseEntity<TopKResponse> getAdvancedTopK(/* parameters */) {
    // Implementation for privileged users
    // ...
}
```

## 6. Operational Considerations

### 6.1. High Availability

- **Service Replication:** Multiple instances behind load balancer
- **Cross-AZ Deployment:** Distribution across availability zones
- **Circuit Breakers:** Protect from downstream failures

```java
@Configuration
public class ResilienceConfig {
    
    @Bean
    public Resilience4jCircuitBreakerFactory circuitBreakerFactory() {
        CircuitBreakerConfig circuitBreakerConfig = CircuitBreakerConfig.custom()
            .failureRateThreshold(50)
            .waitDurationInOpenState(Duration.ofMillis(1000))
            .slidingWindowSize(10)
            .build();
        
        return new Resilience4jCircuitBreakerFactory(Map.of(
            "redis", circuitBreakerConfig,
            "cassandra", circuitBreakerConfig));
    }
    
    @Bean
    public TimeLimiterRegistry timeLimiterRegistry() {
        return TimeLimiterRegistry.of(Map.of(
            "redis", TimeLimiterConfig.custom().timeoutDuration(Duration.ofMillis(500)).build(),
            "cassandra", TimeLimiterConfig.custom().timeoutDuration(Duration.ofSeconds(3)).build()));
    }
}
```

### 6.2. Performance Metrics

```java
@Configuration
public class MetricsConfig {
    
    @Bean
    public MeterRegistry meterRegistry() {
        return new SimpleMeterRegistry();
    }
    
    @Bean
    public TimedAspect timedAspect(MeterRegistry registry) {
        return new TimedAspect(registry);
    }
}

@Service
public class HeavyHittersService {
    
    private final MeterRegistry meterRegistry;
    
    // Constructor and other methods...
    
    @Timed(value = "topk.query", extraTags = {"source", "redis"})
    private TopKResult getTopKFromRedis(TopKQuery query) {
        // Implementation...
    }
    
    @Timed(value = "topk.query", extraTags = {"source", "cassandra"})
    private TopKResult getTopKFromCassandra(TopKQuery query) {
        // Implementation...
    }
}
```

## 7. Deployment Configuration

```yaml
# application.yml
spring:
  application:
    name: heavy-hitters-query-service
  profiles:
    active: ${SPRING_PROFILES_ACTIVE:local}
  redis:
    host: ${REDIS_HOST:localhost}
    port: ${REDIS_PORT:6379}
    timeout: 500ms
  data:
    cassandra:
      contact-points: ${CASSANDRA_HOSTS:localhost}
      port: ${CASSANDRA_PORT:9042}
      keyspace: ${CASSANDRA_KEYSPACE:heavy_hitters}
      read-timeout: 3s

server:
  port: ${SERVER_PORT:8080}
  compression:
    enabled: true
  http2:
    enabled: true

management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus
  metrics:
    export:
      prometheus:
        enabled: true

cache:
  max-size: ${CACHE_MAX_SIZE:1000}
  ttl:
    default: ${CACHE_DEFAULT_TTL:60}  # seconds
    short: ${CACHE_SHORT_TTL:10}      # seconds
    long: ${CACHE_LONG_TTL:600}       # seconds

query:
  max-k: ${QUERY_MAX_K:1000}
  default-k: ${QUERY_DEFAULT_K:10}
```

## 8. API Documentation

### 8.1. OpenAPI Configuration

```java
@Configuration
public class OpenApiConfig {
    
    @Bean
    public OpenAPI customOpenAPI() {
        return new OpenAPI()
            .info(new Info()
                .title("Top K Heavy Hitters API")
                .version("1.0")
                .description("API for querying top K frequent items from event streams")
                .contact(new Contact()
                    .name("API Support")
                    .email("api@example.com"))
            )
            .components(new Components()
                .addSecuritySchemes("bearer-jwt",
                    new SecurityScheme()
                        .type(SecurityScheme.Type.HTTP)
                        .scheme("bearer")
                        .bearerFormat("JWT")
                )
            )
            .addSecurityItem(
                new SecurityRequirement().addList("bearer-jwt"));
    }
}
```
